##### 1.快速排序

```java
//思路
public static void quickSort(int[] q,int l,int r){
        if(l >= r) return;
        int x = q[l],i = l - 1,j = r + 1; //取q[l]作为边界
        while(i < j){
          //严格保证x左边的数小于x，x右边的数大于x
            do i ++; while(q[i] < x); 
            do j --; while(q[j] > x);
            if(i < j){
                int t = q[i];
                q[i] = q[j];
                q[j] = t;
            }
        }
  		  //递归处理边界的左右区间
        quickSort(q,l,j);
        quickSort(q,j + 1,r);
    }
  
```

##### 时间复杂度和边界值的选取有关

##### 最好情况时间复杂度：O(n * logn) 一共递归logn层，每层遍历n个元素

##### 最坏情况时间复杂度：O(n ^ 2) 即数组有序的情况 ： (n *( n - 1)) / 2

##### 2.归并排序

```java
public static void mergeSort(int[] m,int l,int r){
        if(l >= r) return;
        int mid = (l + r) / 2;
  			//递归处理左右两边区间
        mergeSort(m,l,mid);
        mergeSort(m,mid + 1,r);
        int[] temp = new int[100010];
        int k = 0;
        int i = l,j = mid + 1;
  			//合并两个有序区间，并且使合并后的区间仍然有序
        while(i <= mid && j <= r){
            if(m[i] <= m[j]) temp[k ++] = m[i ++];
            else temp[k ++] = m[j ++];
        }
        while(i <= mid) temp[k ++] = m[i ++];
        while(j <= r) temp[k ++] = m[j ++];
        for(i = l,j = 0;i <= r;i ++,j ++) m[i] = temp[j];
    }
```

##### 时间复杂度：O(n * logn)

##### 3.高精度



##### 4.前缀和与差分

##### 5.双指针算法

##### 6.位运算

##### 7.离散化

##### 8.区间合并

